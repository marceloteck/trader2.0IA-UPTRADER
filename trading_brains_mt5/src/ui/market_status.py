"""
Market Status Engine - IA Trabalhando em Tempo Real

Gera status do mercado combinando informa√ß√µes de:
- Regime Detection (L3)
- Uncertainty Gates (L2)
- Liquidity Analysis (L4)
- Cross-Market (L6)
- Macro Brain (H1)
"""

from __future__ import annotations

from dataclasses import dataclass, field, asdict
from datetime import datetime
from enum import Enum
from typing import Optional, Dict, List, Any
import logging

logger = logging.getLogger(__name__)


class RiskState(Enum):
    """Risk state of the market."""
    OK = "OK"
    CAUTION = "CAUTION"
    BLOCKED = "BLOCKED"


@dataclass
class MarketStatus:
    """Current market status generated by AI."""
    
    timestamp: datetime
    symbol: str
    headline: str  # Ex: "Tend√™ncia de alta confirmada"
    phase: str  # Ex: "Aguardando pullback para compra"
    risk_state: str  # "OK" | "CAUTION" | "BLOCKED"
    reasons: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict for JSON serialization."""
        return {
            'timestamp': self.timestamp.isoformat(),
            'symbol': self.symbol,
            'headline': self.headline,
            'phase': self.phase,
            'risk_state': self.risk_state,
            'reasons': self.reasons,
            'metadata': self.metadata
        }


@dataclass
class MarketStatusContext:
    """Context for status generation."""
    
    symbol: str
    regime: Optional[str] = None  # TREND_UP, TREND_DOWN, RANGE, TRANSITION, CHAOTIC
    transition_active: bool = False
    ensemble_confidence: Optional[float] = None  # 0-1
    conformal_coverage: Optional[float] = None  # 0-1
    model_disagreement: Optional[float] = None  # 0-1
    
    liquidity_strength: Optional[float] = None  # 0-1
    zone_proximity: Optional[str] = None  # NEAR_TP, NEAR_SL, SAFE, NEUTRAL
    volatility_level: Optional[str] = None  # LOW, NORMAL, HIGH, EXTREME
    
    cross_signal_type: Optional[str] = None  # CONFIRM_BUY, REDUCE_BUY, MARKET_BROKEN, etc
    cross_correlation: Optional[float] = None  # -1 to 1
    news_blocked: bool = False
    news_risk_factor: Optional[float] = None  # 0.5 = reduced, 1.0 = normal
    
    macro_signal: Optional[str] = None  # BUY, SELL, NEUTRAL
    macro_phase: Optional[str] = None  # ACCUMULATION, MARKUP, DISTRIBUTION, MARKDOWN


class MarketStatusEngine:
    """
    Generates market status using multiple signals.
    
    Combines L3 regime, L2 uncertainty, L4 liquidity, L6 cross-market, macro signals.
    """
    
    def __init__(self):
        pass
    
    def generate_status(self, context: MarketStatusContext) -> MarketStatus:
        """
        Generate market status from context.
        
        Args:
            context: MarketStatusContext with all available signals
        
        Returns:
            MarketStatus with headline, phase, risk_state, and reasons
        """
        now = datetime.now()
        
        # Determine headline based on regime and signals
        headline = self._generate_headline(context)
        
        # Determine current phase
        phase = self._determine_phase(context)
        
        # Calculate risk state
        risk_state = self._calculate_risk_state(context)
        
        # Collect reasons
        reasons = self._collect_reasons(context)
        
        # Build metadata
        metadata = self._build_metadata(context)
        
        return MarketStatus(
            timestamp=now,
            symbol=context.symbol,
            headline=headline,
            phase=phase,
            risk_state=risk_state,
            reasons=reasons,
            metadata=metadata
        )
    
    def _generate_headline(self, context: MarketStatusContext) -> str:
        """Generate main headline based on regime and signals."""
        
        # If news blocked, override everything
        if context.news_blocked:
            return "üö´ Bloqueado por evento econ√¥mico"
        
        # If market broken correlation
        if context.cross_signal_type == 'MARKET_BROKEN':
            return "‚ö†Ô∏è Correla√ß√£o quebrada - Mercado desalinhado"
        
        # Base on regime
        if context.regime == 'TREND_UP':
            if context.cross_signal_type == 'CONFIRM_BUY':
                return "üìà Tend√™ncia de ALTA confirmada (multi-mercado)"
            elif context.cross_signal_type in ['REDUCE_BUY', 'REDUCE_SELL']:
                return "üìà Tend√™ncia de ALTA (alerta de redu√ß√£o)"
            return "üìà Tend√™ncia de ALTA confirmada"
        
        elif context.regime == 'TREND_DOWN':
            if context.cross_signal_type == 'CONFIRM_SELL':
                return "üìâ Tend√™ncia de BAIXA confirmada (multi-mercado)"
            elif context.cross_signal_type in ['REDUCE_SELL', 'REDUCE_BUY']:
                return "üìâ Tend√™ncia de BAIXA (alerta de redu√ß√£o)"
            return "üìâ Tend√™ncia de BAIXA confirmada"
        
        elif context.regime == 'RANGE':
            if context.zone_proximity == 'NEAR_TP':
                return "üìä Em range - Pr√≥ximo ao suporte para compra"
            elif context.zone_proximity == 'NEAR_SL':
                return "üìä Em range - Pr√≥ximo √† resist√™ncia para venda"
            return "üìä Mercado em range - Aguardando breakout"
        
        elif context.regime == 'TRANSITION':
            return "üîÑ Em transi√ß√£o de regime - Prud√™ncia recomendada"
        
        elif context.regime == 'CHAOTIC':
            return "üå™Ô∏è Mercado ca√≥tico - Alto risco de sinaliza√ß√£o falsa"
        
        # Default
        return "‚ùì Status incerto - Coletar mais dados"
    
    def _determine_phase(self, context: MarketStatusContext) -> str:
        """Determine current trading phase."""
        
        # If blocked
        if context.news_blocked:
            return f"Aguardando libera√ß√£o (risco reduzido {context.news_risk_factor:.0%})"
        
        # If transition
        if context.transition_active:
            return "Transi√ß√£o de regime em progresso - Esperar confirma√ß√£o"
        
        # If high disagreement or low confidence
        if context.model_disagreement and context.model_disagreement > 0.25:
            return "Incerteza elevada no ensemble - Aguardar confirma√ß√£o adicional"
        
        if context.ensemble_confidence and context.ensemble_confidence < 0.55:
            return "Confian√ßa baixa - N√£o h√° sinal claro, aguardando"
        
        # If in range
        if context.regime == 'RANGE':
            if context.zone_proximity == 'NEAR_TP':
                return "Pr√≥ximo ao suporte - Buscando setup de compra"
            elif context.zone_proximity == 'NEAR_SL':
                return "Pr√≥ximo √† resist√™ncia - Buscando setup de venda"
            return "Em consolida√ß√£o - Aguardando breakout"
        
        # If trend with good liquidity
        if context.regime in ['TREND_UP', 'TREND_DOWN']:
            if context.liquidity_strength and context.liquidity_strength > 0.7:
                return f"Seguindo tend√™ncia com liquidez forte - Pronto para {context.regime}"
            elif context.liquidity_strength and context.liquidity_strength > 0.5:
                return f"Seguindo tend√™ncia - Liquidez moderada"
            else:
                return f"Tend√™ncia fraca em liquidez - Cuidado com stops"
        
        # High volatility caution
        if context.volatility_level == 'EXTREME':
            return "Volatilidade extrema - Reduzir posi√ß√£o ou aguardar"
        
        return "Mercado normal - Aguardando setup de entrada"
    
    def _calculate_risk_state(self, context: MarketStatusContext) -> str:
        """Calculate overall risk state."""
        
        # BLOCKED takes absolute priority
        if context.news_blocked:
            return RiskState.BLOCKED.value
        
        if context.cross_signal_type == 'MARKET_BROKEN':
            return RiskState.BLOCKED.value
        
        if context.regime == 'CHAOTIC':
            return RiskState.BLOCKED.value
        
        # CAUTION - elevated risk
        caution_flags = 0
        caution_threshold = 2
        
        if context.transition_active:
            caution_flags += 1
        
        if context.regime == 'TRANSITION':
            caution_flags += 1
        
        if context.model_disagreement and context.model_disagreement > 0.20:
            caution_flags += 1
        
        if context.ensemble_confidence and context.ensemble_confidence < 0.65:
            caution_flags += 1
        
        if context.cross_signal_type in ['REDUCE_BUY', 'REDUCE_SELL']:
            caution_flags += 1
        
        if context.volatility_level in ['HIGH', 'EXTREME']:
            caution_flags += 1
        
        if context.liquidity_strength and context.liquidity_strength < 0.4:
            caution_flags += 1
        
        if caution_flags >= caution_threshold:
            return RiskState.CAUTION.value
        
        # OK - normal trading
        return RiskState.OK.value
    
    def _collect_reasons(self, context: MarketStatusContext) -> List[str]:
        """Collect reasons for current status."""
        reasons = []
        
        # Regime
        if context.regime:
            regime_map = {
                'TREND_UP': '‚úì Tend√™ncia para cima confirmada',
                'TREND_DOWN': '‚úì Tend√™ncia para baixo confirmada',
                'RANGE': '‚äô Mercado consolidando',
                'TRANSITION': 'üîÑ Transi√ß√£o de regime',
                'CHAOTIC': '‚úó Mercado ca√≥tico/desorganizado'
            }
            if context.regime in regime_map:
                reasons.append(regime_map[context.regime])
        
        # Confidence
        if context.ensemble_confidence:
            if context.ensemble_confidence > 0.75:
                reasons.append(f'‚úì Ensemble: {context.ensemble_confidence:.0%} confian√ßa')
            elif context.ensemble_confidence > 0.55:
                reasons.append(f'‚äô Ensemble: {context.ensemble_confidence:.0%} confian√ßa moderada')
            else:
                reasons.append(f'‚úó Ensemble: {context.ensemble_confidence:.0%} confian√ßa baixa')
        
        # Model disagreement
        if context.model_disagreement:
            if context.model_disagreement < 0.15:
                reasons.append(f'‚úì Consenso: modelos alinhados ({context.model_disagreement:.1%} desacordo)')
            elif context.model_disagreement < 0.25:
                reasons.append(f'‚äô Modelos com leve desacordo ({context.model_disagreement:.1%})')
            else:
                reasons.append(f'‚úó Desacordo alto entre modelos ({context.model_disagreement:.1%})')
        
        # Liquidity
        if context.liquidity_strength:
            if context.liquidity_strength > 0.7:
                reasons.append(f'‚úì Liquidez forte: {context.liquidity_strength:.0%}')
            elif context.liquidity_strength > 0.5:
                reasons.append(f'‚äô Liquidez moderada: {context.liquidity_strength:.0%}')
            else:
                reasons.append(f'‚úó Liquidez fraca: {context.liquidity_strength:.0%}')
        
        # Cross-market
        if context.cross_signal_type:
            if context.cross_signal_type.startswith('CONFIRM'):
                reasons.append(f'‚úì Multi-mercado confirma sinal')
            elif context.cross_signal_type.startswith('REDUCE'):
                reasons.append(f'‚äô Multi-mercado: reduzir confian√ßa')
            elif context.cross_signal_type == 'MARKET_BROKEN':
                reasons.append(f'‚úó Correla√ß√£o quebrada')
        
        # News
        if context.news_blocked:
            reasons.append(f'üö´ Evento econ√¥mico: {context.news_risk_factor:.0%} risco')
        
        # Volatility
        if context.volatility_level == 'EXTREME':
            reasons.append(f'‚ö†Ô∏è Volatilidade extrema')
        elif context.volatility_level == 'HIGH':
            reasons.append(f'‚äô Volatilidade elevada')
        
        # Macro
        if context.macro_signal:
            macro_map = {
                'BUY': 'üìà Macro: sinal de compra',
                'SELL': 'üìâ Macro: sinal de venda',
                'NEUTRAL': '‚äô Macro: sem sinal claro'
            }
            if context.macro_signal in macro_map:
                reasons.append(macro_map[context.macro_signal])
        
        return reasons if reasons else ["‚äô Aguardando mais dados para an√°lise"]
    
    def _build_metadata(self, context: MarketStatusContext) -> Dict[str, Any]:
        """Build metadata dictionary."""
        return {
            'regime': context.regime,
            'transition_active': context.transition_active,
            'ensemble_confidence': context.ensemble_confidence,
            'conformal_coverage': context.conformal_coverage,
            'model_disagreement': context.model_disagreement,
            'liquidity_strength': context.liquidity_strength,
            'zone_proximity': context.zone_proximity,
            'volatility_level': context.volatility_level,
            'cross_signal_type': context.cross_signal_type,
            'cross_correlation': context.cross_correlation,
            'news_blocked': context.news_blocked,
            'news_risk_factor': context.news_risk_factor,
            'macro_signal': context.macro_signal,
            'macro_phase': context.macro_phase
        }
